function body(field) {
  const checks = [];
  const chain = function(req, res, next) {
    const value = req.body ? req.body[field] : undefined;
    for (const check of checks) {
      let valid = true;
      switch (check.type) {
        case 'notEmpty':
          valid = value !== undefined && value !== null && value !== '';
          break;
        case 'isEmail':
          valid = typeof value === 'string' && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
          break;
        case 'isInt':
          valid = Number.isInteger(Number(value));
          break;
        case 'isNumeric':
          valid = !isNaN(parseFloat(value));
          break;
        case 'custom':
          valid = check.fn(value, { req });
          break;
      }
      if (!valid) {
        req._validationErrors = req._validationErrors || [];
        req._validationErrors.push({ msg: check.msg || 'Invalid value', param: field });
        break;
      }
    }
    next();
  };
  chain.notEmpty = () => { checks.push({ type: 'notEmpty' }); return chain; };
  chain.isEmail = () => { checks.push({ type: 'isEmail' }); return chain; };
  chain.isInt = () => { checks.push({ type: 'isInt' }); return chain; };
  chain.isNumeric = () => { checks.push({ type: 'isNumeric' }); return chain; };
  chain.custom = fn => { checks.push({ type: 'custom', fn }); return chain; };
  chain.withMessage = msg => { if (checks.length) checks[checks.length - 1].msg = msg; return chain; };
  return chain;
}

function validationResult(req) {
  const errors = req._validationErrors || [];
  return {
    isEmpty: () => errors.length === 0,
    array: () => errors
  };
}

module.exports = { body, validationResult };
